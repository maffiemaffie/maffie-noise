export class Noise{constructor(e,s){this.dim=e,this.pow=s,this.res=1<<s,this.merp=new t(e),this.gradientMerp=new t(e-1),this.values=this._init()}_init(){let t=[];for(let e=0;e<1<<this.pow*this.dim;e++)t.push(Math.random());return t}_getBounds(...t){let s=[];for(let e=0;e<this.dim;e++)s.push([Math.floor(t[e]),Math.floor(t[e])+1]);let r=[];for(let t=0;t<1<<this.dim;t++){const i=e(t,this.dim),h=[];i.forEach(((t,e)=>{h.push(s[e][t])})),r.push(h)}return r}get(...t){const e=i(this.pow);let s=this._getBounds(...t),r=t.map(((t,e)=>t-s[0][e]));r=r.map((t=>this._mapDecimal(this._smooth(t),-1,1)));let h=s.map((t=>t.map((t=>t&e))));return h=h.map((t=>this._getPoint(...t))),this.merp.merp({values:h,distances:r})}gradient(...t){const e=i(this.pow);let s=this._getBounds(...t),r=s.map((t=>t.map((t=>t&e))));r=r.map((t=>this._getPoint(...t)));let h=t.map(((t,e)=>t-s[0][e])),o=h.map((t=>this._smoothDx(t)));h=h.map((t=>this._mapDecimal(t,-1,1)));let n=[];for(let t=0;t<this.dim;t++){let e=[],i=[];for(let r=0;r<s.length>>1;r++)e.push((r>>t<<t)+r+(1<<t)),i.push((r>>t<<t)+r);const a=e.map(((t,e)=>r[t]-r[i[e]])),l=h.filter(((e,s)=>s!==t));n.push(o[t]*this.gradientMerp.merp({values:a,distances:l}))}return n}_getPoint(...t){return this.values[this._toIndex(...t)]}_toIndex(...t){const e=(t,...s)=>0===s.length?0:(s[0]<<t)+e(t+this.pow,...s.slice(1));return e(0,...t)}_toCoords(t){const e=i(this.pow);let s=[];for(let r=0;r<this.dim;r++,t>>=this.pow)s.push(t&e);return s}_mapDecimal(t,e,s){return t*s+(1-t)*e}_smooth(t){return t*t*t*(10+t*(6*t-15))}_smoothDx(t){return 30*t*t*(1+t*(-2+t))}}export class OctaveNoise{constructor(t,e,s){let r=[];for(let i=0;i<s;i++)r.push(new Noise(t,e));this.octaves=r,this.dim=t}get(...t){let e=this.octaves.reduce(((e,s,r)=>{const i=t.map((t=>t*(1<<r)));return e+(this.octaves.length-r)*(this.octaves.length-r)*s.get(...i)}),0);const s=this.octaves.length;return e/=s*(s+1)*(2*s+1)/6,e}gradient(...t){const e=[];for(let t=0;t<this.dim;t++,e.push(0));let s=this.octaves.reduce(((e,s,r)=>{const i=t.map((t=>t*(1<<r))),h=(this.octaves.length-r)*(this.octaves.length-r),o=s.gradient(...i);return e.map(((t,e)=>t+h*o[e]))}),e);const r=this.octaves.length,i=r*(r+1)*(2*r+1)/6;return s=s.map((t=>t/i)),s}}class t{constructor(t){const r=1<<t;this.scalar=1/r,this.merpArrayN=[];for(let t=0;t<r;t++)this.merpArrayN[t]=[];for(let i=0;i<r;i++)for(let h=0;h<r;h++)this.merpArrayN[i][h]=!!s(...e(i|~h,t))}merp({values:t,distances:e}){const s=this._getWeightProducts(...e),i=[];for(let e=0;e<t.length;e++)i.push(this._signDot(this.merpArrayN[e],s));return this.scalar*r(t,i)}_getWeightProducts(...t){const e=s=>-1===s?[1]:[...e(s-1),...e(s-1).map((e=>t[s]*e))];return e(t.length-1)}_signDot(t,e){if(t.length!==e.length)throw"DIE DIE DIE DIE DIE";return e.reduce(((e,s,r)=>t[r]?e+s:e-s))}}const e=(t,e)=>{const s=[];for(let r=0;r<e;r++,t>>=1)s[r]=1&t;return s},s=(...t)=>!(1&t.reduce(((t,e)=>t+(e?0:1)),0)),r=(t,e)=>{if(t.length!==e.length)throw"DIE DIE DIE DIE DIE";return t.reduce(((t,s,r)=>t+s*e[r]),0)},i=t=>(1<<t)-1;